# COLUMNAS NUEVAS

?? hour_of_day y day_of_week: hora y día codificados como cíclicos (sin, cos), muy predictivos de skips.

# 
user_time_since_last_play: minutos desde la última reproducción.
user_artist_weekend_consumed: booleana si el artista fue escuchado en fin de semana o en la semana.
user_artist_seen_before: booleana si ya escuchó ese artista antes.
user_track_seen_before: booleana si esa canción ya fue escuchada alguna vez.
user_artist_listens_count: cuántas veces escuchó ese artista en total.
user_track_listens_count: cantidad total de escuchas previas del track.
user_album_seen_before: si ya escuchó algo de ese álbum.
user_genre_seen_before: si el género del track ya apareció en el historial del usuario (si tenés géneros disponibles).
user_explicit_rate: proporción de canciones explicitas escuchadas por el usuario
user_is_explicit_tolerate: booleana que indica que el usuario tolera canciones explicitas (user_explicit_rate > 0.5)
user_unique_artists_ratio: nº de artistas distintos / total escuchas → mide diversidad musical.
user_novelty_rate: proporción de canciones “nuevas” (release < 30 días) que escucha.
user_replay_rate: proporción de canciones repetidas.

popularity_bin: segmentar popularidad en buckets (p. ej. bajo <30, medio 30–70, alto >70).
track_duration_bin: segmentar duración de canción en categorías (no tener en cuenta duración de podcasts para no alterar) y obtener skip rate promedio por bin.
episode_duration_bin: segmentar duración de episodio en categorías (no tener en cuenta duración de tracks para no alterar) y obtener skip rate promedio por bin.

# 
is_mobile_device: booleana derivada del operative_system (iOS/Android).
is_new_release: tiempo de release menor a 30 días

# Diferencia con la canción anterior
user_last_track_duration: duración de la última canción escuchada del usuario

# Agrupando por sesión: Cada sesión se identifica si la canción anterior escuchada por el usuario fue hace más de 1 hora
user_value_listen_count: cantidad de canciones escuchadas por el usuario en la sesión de la observación
user_value_listen_duration: cantidad de minutos escuchados por el usuario en la sesión de la observación
user_session_total_duration: duración total de la sesión hasta el momento
user_session_position: posición del track dentro de la sesión (los usuarios tienden a skipear más al inicio).
user_mean_listen_count: media de cantidad de canciones por sesión por usuario
user_var_listen_count: varianza de cantidad de canciones por sesión por usuario
user_mean_listen_duration: media de minutos escuchados por sesión por usuario
user_var_listen_duration: varianza de minutos escuchados por sesión por usuario
user_session_popular_gender: genero más popular escuchado en la sesión


# Calcular métricas por user y agregar columnas sobre esas variables. Ejemplo:
user_likes_this_genre: proporción de canciones escuchadas por el usuario con alguno de los géneros actuales.
user_rarely_listens_this_genre: si el género actual está fuera de su top N géneros más reproducidos.
genre_novelty: qué tan distinto es el género actual respecto al historial (diversidad o exploración).
genre_repetition: si repite un género que ya escuchó recientemente.
proportion_danceable_listened: 
proportion_romantic_listened: 
proportion_spanish_listened: 
proportion_modern_listened: 
user_avg_genre_entropy: 
user_main_language:  (por moda)
user_top_genre_cluster:  (cluster dominante)
user_prefers_high_energy:  (porcentaje de temas de alta energía escuchados)
user_skips_rate_for_chill_genres:  (si podés cruzar con el target anterior)



# IDEAS
Por usuario, cuando saltaste a una canción diferente es más probable el skip.

Cantidad de canciones escuchadas por usuario previas a la actual.

Promedio de tiempo de las canciones que escucha un usuario
    A partir de esto genero: La canción está por encima del promedio o no (o un rango)

BUSCAR GENERO DE LAS CANCIONES Y DE QUÉ TIPO ES EL EPISODIO
    En vez de usar nombres y todo eso lo resumimos a eso. Puede ser con PCA, clusters, buscar datos reales, etc.

Usar un punto de corte temporal en vez de 2024 y pre 2024, porque sino queda menos de 10% para validation.

Los datos de test a predecir son a partir de 2024-09-01, los de train hasta 2024-08-31
    No sé si es mejor usar 2024 para validation, xq igual no tenemos datos con fechas que coincidan con el conj de test
    X ahi es mejor hacer validaciones cross por tiempo
